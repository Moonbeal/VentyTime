@using VentyTime.Client.Services
@using VentyTime.Shared.Models
@using MudBlazor
@inject INotificationService NotificationService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject ILogger<NotificationList> _logger
@implements IDisposable

<MudMenu Icon="@Icons.Material.Filled.Notifications" Color="Color.Inherit" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
    <ActivatorContent>
        <MudIconButton Icon="@Icons.Material.Filled.Notifications" 
                      Color="@(unreadCount > 0 ? Color.Secondary : Color.Inherit)"
                      Class="@(unreadCount > 0 ? "notification-bell-active" : "")">
            @if (unreadCount > 0)
            {
                <MudBadge Color="Color.Secondary" Content="@unreadCount" Overlap="true" />
            }
        </MudIconButton>
    </ActivatorContent>
    <ChildContent>
        <MudList Dense="true" Class="pa-0" Style="min-width: 300px; max-height: 400px; overflow-y: auto;">
            @if (!notifications.Any())
            {
                <MudListItem>
                    <MudText Typo="Typo.body2">No notifications</MudText>
                </MudListItem>
            }
            else
            {
                <MudListItem>
                    <div class="d-flex justify-space-between align-center w-100">
                        <MudText Typo="Typo.subtitle1" Class="mr-2">Notifications</MudText>
                        @if (notifications.Any(n => !n.IsRead))
                        {
                            <MudButton Size="Size.Small"
                                      Color="Color.Primary" 
                                      Variant="Variant.Text" 
                                      OnClick="MarkAllAsRead">
                                Mark all as read
                            </MudButton>
                        }
                    </div>
                </MudListItem>
                <MudDivider />
                @foreach (var notification in notifications.OrderByDescending(n => n.CreatedAt))
                {
                    <MudListItem @key="notification.Id" Class="@(!notification.IsRead ? "unread" : "")" OnClick="@(() => HandleNotificationClick(notification))">
                        <div class="d-flex flex-column">
                            <MudText Typo="Typo.subtitle2">@notification.Title</MudText>
                            <MudText Typo="Typo.body2">@notification.Message</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">@GetTimeAgo(notification.CreatedAt)</MudText>
                        </div>
                    </MudListItem>
                }
            }
        </MudList>
    </ChildContent>
</MudMenu>

<style>
    .unread {
        background-color: var(--mud-palette-background-grey);
    }

    .notification-bell-active {
        animation: bellPulse 2s infinite;
    }

    @@keyframes bellPulse {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.1);
            opacity: 0.9;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
</style>

@code {
    private List<Notification> notifications = new();
    private int unreadCount = 0;
    private readonly DateTimeOffset _currentTime = DateTimeOffset.Parse("2025-01-07T15:06:11+02:00");

    protected override async Task OnInitializedAsync()
    {
        NotificationService.OnNotificationsChanged += OnNotificationsChanged;
        await LoadNotifications();
        await UpdateUnreadCount();
    }

    private async Task LoadNotifications()
    {
        notifications = await NotificationService.GetNotificationsAsync();
        StateHasChanged();
    }

    private async Task UpdateUnreadCount()
    {
        unreadCount = await NotificationService.GetUnreadCountAsync();
        StateHasChanged();
    }

    private async Task MarkAllAsRead()
    {
        try
        {
            await NotificationService.MarkAllAsReadAsync();
            await LoadNotifications();
            await UpdateUnreadCount();
            Snackbar.Add("All notifications marked as read");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to mark all notifications as read");
            Snackbar.Add("Failed to mark notifications as read");
        }
    }

    private async Task MarkAsRead(int notificationId)
    {
        try
        {
            await NotificationService.MarkAsReadAsync(notificationId);
            await LoadNotifications();
            await UpdateUnreadCount();
            Snackbar.Add("Notification marked as read");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to mark notification as read");
            Snackbar.Add("Failed to mark notification as read");
        }
    }

    private async Task HandleNotificationClick(Notification notification)
    {
        try
        {
            if (!notification.IsRead)
            {
                await MarkAsRead(notification.Id);
            }

            if (!string.IsNullOrEmpty(notification.Link))
            {
                NavigationManager.NavigateTo(notification.Link);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling notification click: {ex}");
        }
    }

    private string GetTimeAgo(DateTime timestamp)
    {
        var timeSpan = _currentTime.DateTime - timestamp;

        if (timeSpan.TotalMinutes < 1)
            return "just now";
        if (timeSpan.TotalMinutes < 60)
            return $"{(int)timeSpan.TotalMinutes}m ago";
        if (timeSpan.TotalHours < 24)
            return $"{(int)timeSpan.TotalHours}h ago";
        if (timeSpan.TotalDays < 7)
            return $"{(int)timeSpan.TotalDays}d ago";
        return timestamp.ToString("MMM dd, yyyy");
    }

    public void Dispose()
    {
        NotificationService.OnNotificationsChanged -= OnNotificationsChanged;
    }

    private async void OnNotificationsChanged()
    {
        try
        {
            _logger.LogInformation("Notifications changed, refreshing...");
            await LoadNotifications();
            await UpdateUnreadCount();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error in OnNotificationsChanged");
        }
    }
}
